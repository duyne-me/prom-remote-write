# Metrics Reference

Comprehensive documentation for all metrics generated by the mock-exporter-python.

## Overview

The mock exporter generates **20+ production-like metrics** following Prometheus naming conventions, including:

- **HTTP Service Metrics** (RED method): Rate, Errors, Duration
- **Node/System Metrics** (USE method): Utilization, Saturation, Errors
- **Application Business Metrics**: Custom business KPIs

## Table of Contents

- [HTTP Service Metrics](#http-service-metrics-red-method)
  - [http_request_duration_seconds](#http_request_duration_seconds)
  - [http_requests_total](#http_requests_total)
  - [http_request_size_bytes](#http_request_size_bytes)
  - [http_response_size_bytes](#http_response_size_bytes)
- [Node/System Metrics](#nodesystem-metrics-use-method)
  - [node_cpu_seconds_total](#node_cpu_seconds_total)
  - [node_memory_MemTotal_bytes](#node_memory_memtotal_bytes)
  - [node_memory_MemAvailable_bytes](#node_memory_memavailable_bytes)
  - [node_disk_io_time_seconds_total](#node_disk_io_time_seconds_total)
  - [node_network_transmit_bytes_total](#node_network_transmit_bytes_total)
  - [node_network_receive_bytes_total](#node_network_receive_bytes_total)
  - [node_filesystem_size_bytes](#node_filesystem_size_bytes)
  - [node_filesystem_avail_bytes](#node_filesystem_avail_bytes)
- [Application Business Metrics](#application-business-metrics)
  - [app_errors_total](#app_errors_total)
  - [app_database_queries_duration_seconds](#app_database_queries_duration_seconds)
  - [app_database_connections_active](#app_database_connections_active)
  - [app_cache_requests_total](#app_cache_requests_total)
  - [app_queue_size](#app_queue_size)
  - [app_worker_tasks_duration_seconds](#app_worker_tasks_duration_seconds)
  - [app_business_transactions_total](#app_business_transactions_total)
- [Multi-Region Queries](#multi-region-queries)
- [Alerting Rules Examples](#alerting-rules-examples)
- [Dashboard Panels](#dashboard-panels)

## HTTP Service Metrics (RED Method)

### http_request_duration_seconds
**Type**: Histogram  
**Description**: Request duration distribution  
**Labels**: `method`, `path`, `status_code`, `service`  
**Buckets**: `[0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]`

**Use Cases**:
- Monitor response time percentiles (P50, P95, P99)
- Set up latency alerts
- Compare performance across services

**Query Examples**:
```promql
# P95 latency
histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))

# Average latency by service
sum(rate(http_request_duration_seconds_sum[5m])) / sum(rate(http_request_duration_seconds_count[5m]))

# Latency by method
histogram_quantile(0.95, sum by (method) (rate(http_request_duration_seconds_bucket[5m])))
```

### http_requests_total
**Type**: Counter  
**Description**: Total HTTP requests  
**Labels**: `method`, `path`, `status_code`, `service`

**Use Cases**:
- Monitor request rate
- Track error rates
- Calculate success rates

**Query Examples**:
```promql
# Request rate
rate(http_requests_total[5m])

# Error rate by service
sum by (service) (rate(http_requests_total{status_code!~"2.."}[5m])) / 
sum by (service) (rate(http_requests_total[5m])) * 100

# Requests by status code
sum by (status_code) (rate(http_requests_total[5m]))
```

### http_request_size_bytes
**Type**: Histogram  
**Description**: Request body size distribution  
**Labels**: `method`, `path`, `service`  
**Buckets**: `[100, 500, 1000, 5000, 10000, 50000, 100000]`

**Use Cases**:
- Monitor request size patterns
- Detect unusual large requests
- Capacity planning

**Query Examples**:
```promql
# Average request size
sum(rate(http_request_size_bytes_sum[5m])) / sum(rate(http_request_size_bytes_count[5m]))

# P95 request size
histogram_quantile(0.95, rate(http_request_size_bytes_bucket[5m]))
```

### http_response_size_bytes
**Type**: Histogram  
**Description**: Response body size distribution  
**Labels**: `method`, `path`, `status_code`, `service`  
**Buckets**: `[100, 500, 1000, 5000, 10000, 50000, 100000]`

**Use Cases**:
- Monitor response size patterns
- Bandwidth usage analysis
- Performance optimization

伞 **Query Examples**:
```promql
# Average response size
sum(rate(http_response_size_bytes_sum[5m])) / sum(rate(http_response_size_bytes_count[5m]))

# Response size by status code
histogram_quantile(0.95, sum by (status_code) (rate(http_response_size_bytes_bucket[5m])))
```

## Node/System Metrics (USE Method)

### node_cpu_seconds_total
**Type**: Counter  
**Description**: CPU time spent in different modes  
**Labels**: `cpu`, `mode` (user/system/idle/iowait)

**Use Cases**:
- Monitor CPU utilization
- Detect CPU bottlenecks
- Capacity planning

**Query Examples**:
```promql
# CPU utilization percentage
100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)

# CPU usage by mode
rate(node_cpu_seconds_total[5m])

# CPU utilization by core
100 - (rate(node_cpu_ помощи_total{mode="idle"}[5m]) * 100)
```

### node_memory_MemTotal_bytes
**Type**: Gauge  
**Description**: Total memory in bytes  
**Labels**: `host`

**Use Cases**:
- Monitor total memory capacity
- Memory utilization calculations

**Query Examples**:
```promql
# Total memory
node_memory_MemTotal_bytes

# Memory utilization percentage
(1 - node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes) * 100
```

### node_memory_MemAvailable_bytes
**Type**: Gauge  
**Description**: Available memory in bytes  
**Labels**: `host`

**Use Cases**:
- Monitor available memory
- Memory pressure detection
- Alerting on low memory

**Query Examples**:
```promql
# Available memory
node_memory_MemAvailable_bytes

# Memory usage percentage
(1 - node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes) * 100

# Memory usage in GB
node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes
```

### node_disk_io_time_seconds_total
**Type**: Counter  
**Description**: Disk I/O time in seconds  
**Labels**: `device`

**Use Cases**:
- Monitor disk utilization
- Detect disk bottlenecks
- I/O performance analysis

**Query Examples**:
```promql
# Disk utilization percentage
rate(node_disk_io_time_seconds_total[5m]) * 100

# Disk I/O rate by device
rate(node_disk_io_time_seconds_total[5m])
```

### node_network_transmit_bytes_total
**Type**: Counter  
**Description**: Network bytes transmitted  
**Labels**: `device`

**Use Cases**:
- Monitor network throughput
- Bandwidth usage analysis
- Network performance monitoring

**Query Examples**:
```promql
# Network transmit rate
rate(node_network_transmit_bytes_total[5m])

# Total network traffic
rate(node_network_transmit_bytes_total[5m]) + rate(node_network_receive_bytes_total[5m])
```

### node_network_receive_bytes_total
**Type**: Counter  
**Description**: Network bytes received  
**Labels**: `device`

**Use Cases**:
- Monitor network throughput
- Bandwidth usage analysis
- Network performance monitoring

**Query Examples**:
```promql
# Network receive rate
rate(node_network_receive_bytes_total[5m])

# Network utilization
rate(node_network_receive_bytes_total[5m]) + rate(node_network_transmit_bytes_total[5m])
```

### node_filesystem_size_bytes
**Type**: Gauge  
**Description**: Filesystem size in bytes  
**Labels**: `device`, `mountpoint`, `fstype`

**Use Cases**:
- Monitor disk capacity
- Disk usage calculations
- Storage planning

**Query Examples**:
```promql
# Filesystem size
node_filesystem_size_bytes

# Disk usage percentage
(1 - node_filesystem_avail_bytes / node_filesystem_size_bytes) * 100
```

### node_filesystem_avail_bytes
**Type**: Gauge  
**Description**: Available filesystem space in bytes  
**Labels**: `device`, `mountpoint`, `fstype`

**Use Cases**:
- Monitor available disk space
- Disk space alerts
- Storage management

**Query Examples**:
```promql
# Available disk space
node_filesystem_avail_bytes

# Disk usage percentage
(1 - node_filesystem_avail_bytes / node_filesystem_size_bytes) * 100

# Disk usage in GB
(node_filesystem_size_bytes - node_filesystem_avail_bytes) / 1024^3
```

## Application Business Metrics

### app_errors_total
**Type**: Counter  
**Description**: Application errors by type  
**Labels**: `error_type`, `service`, `component`

**Use Cases**:
- Monitor error rates
- Error categorization
- Service health monitoring

**Query Examples**:
```promql
# Error rate by service
rate(app_errors_total[5m])

# Error rate by type
sum by (error_type) (rate(app_errors_total[5m息]))

# Error rate percentage
rate(app_errors_total[5m]) / rate(http_requests_total[5m]) * 100
```

### app_database_queries_duration_seconds
**Type**: Histogram padded **Description**: Database query duration  
**Labels**: `query_type`, `database`, `table`  
**Buckets**: `[0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5]`

**Use Cases**:
- Monitor database performance
- Query optimization
- Database bottleneck detection

**Query Examples**:
```promql
# P95 database query time
histogram_quantile(0.95, rate(app_database_queries_duration_seconds_bucket[5m]))

# Average query time by database
sum by (database) (rate(app_database_queries_duration_seconds_sum[5m])) / 
sum by (database) (rate(app_database_queries_duration_seconds_count[5m]))
```

### app_database_connections_active
**Type**: Gauge  
**Description**: Active database connections  
**Labels**: `database`, `state` (idle/active/waiting)

**Use Cases**:
- Monitor connection pool usage
- Database capacity planning
- Connection leak detection

**Query Examples**:
```promql
# Total active connections
sum(app_database_connections_active)

# Connections by state
sum by (state) (app_database_connections_active)

# Connection utilization
app_database_connections_active{state="active"} / 
sum(app_database_connections_active) * 100
```

### app_cache_requests_total
**Type**: Counter  
**Description**: Cache requests  
**Labels**: `cache_name`, `result` (hit/miss)

**Use Cases**:
- Monitor cache performance
- Cache hit ratio analysis
- Cache optimization

**Query Examples**:
```promql
# Cache hit ratio
rate(app_cache_requests_total{result="hit"}[5m]) / 
rate(app_cache_requests_total[5m]) * 100

# Cache requests by result
sum by (result) (rate(app_cache_requests_total[5m]))
```

### app_queue_size
**Type**: Gauge  
**Description**: Queue depth  
**Labels**: `queue_name`, `priority`

**Use Cases**:
- Monitor queue backlog
- Queue processing capacity
- Backlog alerts

**Query Examples**:
```promql
# Total queue size
sum(app_queue_size)

# Queue size by priority
sum by (priority) (app_queue_size)

# High priority queue size
app_queue_size{priority="high"}
```

### app_worker_tasks_duration_seconds
**Type**: Histogram  
**Description**: Background task duration  
**Labels**: `task_type`, `status`  
**Buckets**: `[0.1, 0.5, 1, 2, 5, 10, 30, 60]`

**Use Cases**:
- Monitor background task performance
- Task optimization
- Worker capacity planning

**Query Examples**:
```promql
# P95 task duration
histogram_quantile(0.95, rate(app_worker_tasks_duration_seconds_bucket[5m]))

# Average task duration by type
sum by (task_type) (rate(app_worker_tasks_duration_seconds_sum[5m])) / 
sum by (task_type) (rate(app_worker_tasks_duration_seconds_count[5m]))
```

### app_business_transactions_total
**Type**: Counter  
**Description**: Business transactions  
**Labels**: `transaction_type`, `status`, `customer_tier`

**Use Cases**:
- Monitor business KPIs
- Revenue tracking
- Customer segmentation analysis

**Query Examples**:
```promql
# Transaction rate by type
rate(app_business_transactions_total[5m])

# Success rate by customer tier
rate(app_business_transactions_total{status="success"}[5m]) / 
rate(app_business_transactions_total[5m]) * 100

# Transactions by status
sum by (status) (rate(app_business_transactions_total[5m]))
```

## Multi-Region Queries

### Request Rate by Region
```promql
sum by (region) (rate(http_requests_total[5m]))
```

### Error Rate by Region
```promql
sum by (region) (rate(http_requests_total{status_code!~"2.."}[5m])) / 
sum by (region) (rate(http_requests_total[5m])) * 100
```

### P95 Latency by Region
```promql
histogram_quantile(0.95, sum by (region, le) (rate(http_request_duration_seconds_bucket[5m])))
```

### Memory Usage by Cluster
```promql
avg by (region, cluster) (node_memory_MemAvailable_bytes)
```

## Alerting Rules Examples

### High Error Rate
```yaml
- alert: HighErrorRate
  expr: sum by (service) (rate(http_requests_total{status_code!~"2.."}[5m])) / 
        sum by (service) (rate(http_requests_total[5m])) * 100 > 5
  for: 2m
  labels:
    severity: warning
  annotations:
    summary: "High error rate for {{ $labels.service }}"
```

### High Latency
```yaml
- alert: HighLatency
  expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
  for: 5m
  labels:
    severity: warning
  annotations:
    summary: "High latency detected"
```

### Low Memory
```yaml
- alert: LowMemory
  expr: (1 - node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes) * 100 > 90
  for: 2m
  labels:
    severity: critical
  annotations:
    summary: "Low memory on {{ $labels.host }}"
```

### High Disk Usage
```yaml
- alert: HighDiskUsage
  expr: (1 - node_filesystem_avail_bytes / node_filesystem_size_bytes) * 100 > 85
  for: 5m
  labels:
    severity: warning
  annotations:
    summary: "High disk usage on {{ $labels.mountpoint }}"
```

## vmagent Internal Metrics

These metrics are generated by vmagent itself (via self-scrape).

### scrape_duration_seconds
**Type**: Histogram  
**Description**: Time taken to scrape targets  
**Labels**: `job`, `instance`, `cluster`, `env`, `region`  
**Source**: vmagent internal (self-scrape job)

**Use Cases**:
- Monitor scrape performance
- Identify slow exporters
- Detect network issues between vmagent and targets

**Query Examples**:
```promql
# P95 scrape latency by cluster
histogram_quantile(0.95, sum(rate(scrape_duration_seconds_bucket[5m])) by (le, cluster))

# Scrape duration by job
histogram_quantile(0.95, sum(rate(scrape_duration_seconds_bucket[5m])) by (le, job))

# Identify slow scrapes
scrape_duration_seconds > 5
```

**Dashboard**: Monitoring Stack Health

### vmagent_remotewrite_duration_seconds
**Type**: Histogram  
**Description**: Time taken to send metrics batch to remote storage (vminsert)  
**Labels**: `cluster`, `env`, `region`, `url`  
**Source**: vmagent internal (self-scrape job)

**Note**: Metric name is `vmagent_remotewrite_duration_seconds_bucket` (not `vmagent_remotewrite_send_duration_seconds_bucket`)

**Use Cases**:
- Monitor remote write performance (MOST CRITICAL METRIC)
- Detect network latency issues
- Identify vminsert overload

**Query Examples**:
```promql
# P95 remote write latency by cluster
histogram_quantile(0.95, sum(rate(vmagent_remotewrite_duration_seconds_bucket[5m])) by (le, cluster))

# Remote write latency by region
histogram_quantile(0.95, sum(rate(vmagent_remotewrite_duration_seconds_bucket[5m])) by (le, region))

# P99 latency (outliers)
histogram_quantile(0.99, sum(rate(vmagent_remotewrite_duration_seconds_bucket[5m])) by (le))
```

**Dashboard**: Monitoring Stack Health

**Alert**: p95 > 2s for 5 minutes

### vmagent_remotewrite_pending_bytes
**Type**: Gauge  
**Description**: Bytes waiting to be sent to remote storage  
**Labels**: `cluster`, `env`, `region`, `url`

**Use Cases**:
- Detect network congestion
- Identify vminsert capacity issues
- Predict potential data loss

**Query Examples**:
```promql
# Pending bytes by cluster
vmagent_remotewrite_pending_bytes

# Clusters with backlog
vmagent_remotewrite_pending_bytes > 10000000  # > 10MB
```

**Dashboard**: Monitoring Stack Health

**Alert**: > 10MB for 5 minutes

### vmagent_remotewrite_samples_total
**Type**: Counter  
**Description**: Total samples (metric datapoints) sent to remote storage  
**Labels**: `cluster`, `env`, `region`, `url`

**Use Cases**:
- Calculate ingestion rate
- Track metric volume growth
- Capacity planning

**Query Examples**:
```promql
# Ingestion rate (samples/sec)
sum(rate(vmagent_remotewrite_samples_total[5m]))

# Ingestion rate by cluster
sum(rate(vmagent_remotewrite_samples_total[5m])) by (cluster)

# Ingestion rate by environment
sum(rate(vmagent_remotewrite_samples_total[5m])) by (env)
```

**Dashboard**: Global Infrastructure Overview

### vmagent_remotewrite_errors_total
**Type**: Counter  
**Description**: Total remote write errors  
**Labels**: `cluster`, `env`, `region`, `url`

**Use Cases**:
- Detect vminsert issues
- Network failure detection
- Authentication problems

**Query Examples**:
```promql
# Error rate
rate(vmagent_remotewrite_errors_total[5m])

# Errors by cluster
sum(rate(vmagent_remotewrite_errors_total[5m])) by (cluster)
```

**Alert**: Any errors > 0 for 5 minutes

## Blackbox Exporter Metrics

These metrics are generated by Blackbox Exporter (scraped by vmagents).

### probe_duration_seconds
**Type**: Gauge  
**Description**: Duration of probe in seconds  
**Labels**: `source_region`, `source_env`, `source_cluster`, `target`, `job`  
**Source**: Blackbox Exporter (job="blackbox")

**Use Cases**:
- Monitor cross-region network latency
- Establish latency baselines
- Detect routing changes

**Query Examples**:
```promql
# Probe duration by source region
probe_duration_seconds{job="blackbox"}

# Average latency from specific region
avg(probe_duration_seconds{source_region="us-east-1"})

# Slowest probes
topk(10, probe_duration_seconds{job="blackbox"})
```

**Dashboard**: Cross-Region Latency Monitoring

### probe_success
**Type**: Gauge  
**Description**: Probe success indicator (1 = success, 0 = failure)  
**Labels**: `source_region`, `source_env`, `target`, `job`

**Use Cases**:
- Monitor network connectivity
- Detect outages
- Calculate availability SLOs

**Query Examples**:
```promql
# Success rate by source region
avg(probe_success{job="blackbox"}) by (source_region) * 100

# Failed probes
probe_success{job="blackbox"} == 0

# Overall success rate
avg(probe_success{job="blackbox"}) * 100
```

**Dashboard**: Cross-Region Latency Monitoring

**Alert**: probe_success < 1 for 5 minutes

## VictoriaMetrics Internal Metrics

These metrics are generated by VictoriaMetrics components.

### vm_http_request_duration_seconds
**Type**: Histogram  
**Description**: HTTP request duration for vminsert/vmselect  
**Labels**: `job` (vminsert or vmselect)  
**Source**: VictoriaMetrics components

**Query Examples**:
```promql
# vminsert request duration p95
histogram_quantile(0.95, sum(rate(vm_http_request_duration_seconds_bucket{job="vminsert"}[5m])) by (le))

# vmselect query duration p95
histogram_quantile(0.95, sum(rate(vm_http_request_duration_seconds_bucket{job="vmselect"}[5m])) by (le))
```

**Dashboard**: Monitoring Stack Health

### vm_data_size_bytes
**Type**: Gauge  
**Description**: Total size of stored data in vmstorage  
**Labels**: `job`, `instance`

**Query Examples**:
```promql
# Total storage usage
sum(vm_data_size_bytes)

# Storage per instance
vm_data_size_bytes{job="vmstorage"}
```

**Dashboard**: Monitoring Stack Health

### vm_slow_row_inserts_total
**Type**: Counter  
**Description**: Slow insert operations in vmstorage  
**Labels**: `job`, `instance`

**Query Examples**:
```promql
# Slow inserts rate
rate(vm_slow_row_inserts_total[5m])
```

**Alert**: > 0 indicates disk I/O or memory issues

## Label Reference

### Standard Labels Applied to All Metrics

All metrics scraped by vmagents have these labels from `external_labels`:

| Label | Description | Example Values |
|-------|-------------|----------------|
| `env` | Environment (dev/prod/monitoring) | `dev`, `prod`, `monitoring` |
| `region` | Source region (where vmagent is located) | `us-east-1`, `eu-west-1`, `ap-southeast-1` |
| `storage_region` | Storage region (where VictoriaMetrics cluster is located) | `us-east-1` |
| `cluster` | Cluster identifier | `us-east-1-eks-01-prod` |

**Key Distinction**:
- `region`: Where metrics are **generated** (vmagent location)
- `storage_region`: Where metrics are **stored** (VictoriaMetrics cluster location)
- In centralized architecture, all metrics have `storage_region="us-east-1"` regardless of source region

## Multi-Environment Queries

With the new multi-environment setup, queries can filter by env/cluster/storage_region:

```promql
# Dev environment only
{env="dev"}

# Prod environment only  
{env="prod"}

# Specific cluster
{cluster="us-east-1-eks-01-prod"}

# All metrics stored in us-east-1
{storage_region="us-east-1"}

# Metrics from eu-west-1 but stored in us-east-1 (cross-region)
{region="eu-west-1", storage_region="us-east-1"}

# Compare dev vs prod request rate
sum(rate(http_requests_total[5m])) by (env)

# Compare clusters in same region
sum(rate(http_requests_total{region="us-east-1"}[5m])) by (cluster)

# Cross-region latency analysis (source vs storage)
histogram_quantile(0.95, sum(rate(vmagent_remotewrite_send_duration_seconds_bucket{region!="us-east-1", storage_region="us-east-1"}[5m])) by (le, region))

# HA clusters in US East
{cluster=~"us-east-1-prod-eks-.*"}
```

## Dashboard Panels
- Request rate by region
- Error rate comparison
- P95 latency by region
- Variables: `$region`, `$cluster`

### HTTP Services (RED)
- Request rate by service
- Error rate by service
- Response time (P50/P95) by service
- HTTP status codes breakdown

### Node Metrics (USE)
- CPU utilization
- Memory usage
- Disk I/O
- Network traffic

### Application Metrics
- Transaction rates
- Queue depths
- Cache hit ratio
- Database connections

